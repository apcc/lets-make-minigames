# 1.2 オブジェクト指向とclass
C++のCとの最大の違い、それはclassの追加である。
オブジェクト指向というのは、モノをモノとして扱うプログラミングのことで、それをするための道具がclassなのである。

> オブジェクト指向プログラミング（Object Oriented Programming: OOP）とは、プログラムを手順ではなくて、モノの作成と操作として見る考え方だ。オブジェクトとは「モノ」を意味する。
>「テレビ」というモノを操作するとき、中でどういうプログラムが動いているか知る必要はない。リモコンで操作すれば、動く。
>「こういう”モノ”を作りましょう」「そして、その"モノ"を使いましょう」というのがオブジェクト指向という考え方だと思っていい。
>> [初心者向けに徹底解説！オブジェクト指向とは？](https://eng-entrance.com/what-oop)

クラスの解説は引用したサイトなどを見てもらったほうがわかりやすいと思うが、講座テキストの体をなすために一応書いておく。

## 1.2.1 classの重要単語

次の語は次項以降断りなく使うのでわからなくなったらここを見に来ること。

### インスタンス
クラスは設計図と表現され、それを組み立て実体化したものをインスタンスとよぶ。

### メンバ変数
「モノ」の中の状態を表すための変数。インスタンスごとに別の変数となる。

### メンバ関数(≒ メソッド)
「モノ」を操作する窓口とでも言えばいいだろうか、中の処理を気にせずともこれを通じて操作をすることができる。
特にメンバ変数を操作(代入)するものをセッタ(setter)、
メンバ変数の中身を返すものをゲッタ(getter)とよぶ。

### コンストラクタ
インスタンスを作る特別な関数。インスタンスを作る時一度だけ呼ばれる。
渡された引数をもとにインスタンスを組み立てる。返り値をもたない。

### 継承
あるクラス(親)の機能を改変した新たなクラスを作ること。
特に指定しないものは親クラスのものを引き継ぐ。

### 属性
メンバ変数/関数に属性をつけることができる。
次の種類がある。
- private
  - そのクラスの中のメソッドからしか操作ができない。
- protected
  - そのクラスもしくはそれを継承したクラスからしか操作できない。
- public
  - クラスの外からも操作ができる。

## 1.2.2 classの大切な「お気持ち」
classを触る上で気をつけるべきものをいくつか。
書いていくうちにこれらのありがたみが分かるようになるので

### 関心の分離
上の引用のリモコンの例をそのまま参考にするが、
テレビ本体がリモコンのボタン配置を管理する必要があるだろうか?
リモコンがテレビの受像システムを管理する必要があるだろうか?
本来の責務だけを果たすようなクラスの役割分担を「関心の分離」とよぶ。

### カプセル化
リモコンの喩えを使おう。
テレビのチャンネル選択をもし直接操作できてしまったらどうなるか?
存在しないチャンネルを選択することもできてしまう。
リモコンから操作したときにそれが正しい操作かを確かめてから変更をすることでそれを回避することができる上、あるべきではない操作があったときにエラーを吐くこともできるかもしれない。
このように基本的にメンバの操作を外に許さないことをカプセル化とよぶ。

### 疎結合
身近な例でいうと、USBコントローラなどがそうといえる。
USBコントローラはボタン配置やそれに対して送信される信号が規格で共通化されており、対応している機器ならどれでも同じ操作で対応できる。
このような構造を「疎結合」とよぶ。


## 1.2.3 classの書き方
```cpp
class TestClass {
private: // ここから先はprivateなメンバを宣言
  int a;
public: // ここから先はpublicなメンバを宣言
  TestClass(int b){ // コンストラクタ。
    a=b;
  }
  // TestClass(int b):a(b){} // こう書くこともできる。
  int get_a(){ // ゲッタ
    return a;
  }
  void set_a(int b){ // セッタ
    a=b;
  }
}; // セミコロンを忘れないこと! (犠牲者を何人も見てきた顔)

class TestClass2:public TestClass { // 継承 publicしておくと後々楽
public:
  void set_a(int b)override { // override(上書き)であることを明示 ないときにエラーが出て安全
    // a=b+1; // aはprivateなので操作できない
    set_a(b+1); // set_aはpublicなので操作できる
  }
};

int main(){
  TestClass tc(5);// インスタンスをつくる。ここでコンストラクタの引数を渡す

  // std::cout<<tc.a<<"\n"; // privateなので怒られる
  std::cout<<tc.get_a()<<"\n"; // publicなので怒られない

  tc.a=2; // privateなので怒られる
  tc.set_a(2); // publicなので怒られない

  assert(tc.get_a()==2); // セッタは正しく動いている

  TestClass2 tc2(5);
  tc2.set_a(5);
  assert(tc2.get_a()==6); // 6になっているはず
}
```

### 1.2.3.a 補足:assert
見慣れない書き方があるだろう。
assert関数は`assert.h`をincludeして使うことのできるC言語の機能である。
カッコ内の条件式が偽(0)だったときに該当箇所を表示して終了する。
printfなどでデバッグすると大量にあるときに見逃したり合っているか分かりづらかったりするのでこれを使うことでエラーが発生したときだけ気を向ければよくなる。
プログラムが想定通りに動いているかこれを挿入して確認することをおすすめする。

### 1.2.3.b 補足:臨時オブジェクト
クラスのインスタンスは変数に代入しないと使えないわけではない。次の例を見てほしい。
```cpp
std::cout<<TestClass(5).get_a()<<"\n";
```
コンストラクタに5を渡して作ったインスタンスのメンバ関数`get_a`をすぐに呼び出し、作られたインスタンスは削除される。
今回のclassではあまり得しないが、今後役に立つので覚えておいてほしい。
